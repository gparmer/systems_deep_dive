# Build Systems Deep Dive

## What is a Build System?

- Problem: how do we compile our code into binaries?
- Manual example: simplest solution, but inadequate

    - Will you remember all the commands?
    - Will anyone else know them?

- Script example: simple solution, but inadequate

    - A shell script with a series of commands to compile everything
	- Downsides: compiles *everything* every time it is run, massive redundancy in specification, what if we need to change how files are compiled?

- Build system requirements:

	- Dependency specification: Which files depend on which other files to build?
    - Task description: to build a file, what commands need to execute?
    - Avoid repeated work: rebuild only out-of-date files, not all of them.

- `make` as an example build system

	- Very "low-level", but good to understand the basics
	- Versatile: can be used to do almost anything
	- Pervasive: massively used

## Makefile Basics

- Files - yeah, those things
- Rules - A statement of the shape:

    ```
	target: dependencies
	<TAB>task_description
	```
	The `:` separates the name of the rule from its dependencies, and the `task_description` (that can be multiple lines) is all `<TAB>` (real tabs, not the word)-delimited

- Dependencies - rules have dependencies on files or rules
- Task descriptions - the tasks to run to generate the target file(s), often compilation commands

## Makefiles and C

We want our modifications to header files (`.h` or `.hpp` files) to cause recompilations in C files.
Thus, we need to teach `make` how to understand header file dependencies.

The C compiler takes flags `-MP -MD` which say to generate Makefile rules for each `*.o`, and `*.h` file (`-MP`), and output them into `*.d` ("dependency") files.
Next, these `*.d` files need to be included in the Makefile, which is done using `-include $(wildcard *.d)`.
The `-include` directive, adds the following files to the Makefile itself (i.e. it "includes it"), and the `wildcard` (as we'll see later) lets us generate a list of all such dependency files.

### Implicit [Variables](https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html)

- `CC` - The C compiler to use
- `CXX` - The C++ compiler to use
- `LD` - The linker to use
- `RM` - by default: `rm -f`
- `CFLAGS` - flags given to the C compiler
- `CXXFLAGS` - flags given to the C++ compiler
- `LDFLAGS` - flags to give to the linker

### Implicit [Rules](https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html)

There are implicit rules for compiling all of the following (and more):

- `.o` files which will use your C or C++ compiler
- binaries which are generated differently depending on what you depend on (e.g. will use the C linker if the dependencies are `.o` files)
- ...

### Target [Conventions](http://www.math.utah.edu/docs/info/standards_5.html)

- `clean` - Remove files that are commonly generated by the build system, but not those that we got from outside of our code (for example, code that was downloaded, thus unlikely to change)
- `distclean` - Remove *all* files and start from scratch
- `all` - Build all files! This should usually be the *first rule*, thus run when you type `make` without a rule
- `dist` - Build a file that enables distribution of the application (e.g. a tarball or zip file)
- `check` - Run the tests for the code
- `install` - Install the code into the system

## Generic Makefiles

We use use variables, rules, and functions to write generic Makefiles that can work (perhaps with small tweaks) for many projects.

### Makefile Functions

Makefiles have a number of [useful functions](https://www.gnu.org/software/make/manual/html_node/Functions.html) you can use.

- `$(wildcard pattern)` where `pattern` can include `*` to match anything

    - Example: `CFILES = $(wildcard *.c)`

- `$(patsubst pattern,replacement,text)` where any `%` is used to provide wild-card replacement (can be rewritten as `$(variable:pattern=replacement)`)

    - Example: `CFILES = $(patsubst %.o,%.c,$COBJECTS)` which is the same as `CFILES = $(COBJECTS:%.o=%.c)`

- `$(filter pattern, text)` which keeps only words in `text` that match the `pattern`

    - Example: `CFILES = $(filter %c,$(ALL_FILES))`

- `$(foreach varname,text,output)` which enables you to iterate, word-for-word through `text`, sets the variable name `varname` to that word, and then uses it in `output` to generate a new output.

    - We'll see examples in the sample Makefiles

- `$(shell command)` where `command` is a UNIX shell command, will simply execute that command on the shell, and the output will be returned

    - Example: `CFILES := $(shell echo *.c)` which will invoke the shell, executing `echo *.c`, which is, in this case, identical to the wildcard output above (it is better to use the builtin functions, not `shell`, where possible)

- `$(error text)`, `$(warning text)`, and `$(info text)` where `text` is some text you provide, each print out the text where `error` exits the build, `warning` does not, and `info` just prints without also printing the location in the Makefile


## Build System Mechanics

Use of file modification times to determine if dependencies have been modified.

### Build System Research

- [Generic abstractions to build a generic build system.](https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems-final.pdf)
- [Forward build systems that automatically determine dependencies](https://dl.acm.org/doi/10.1145/3428237), and, despite this, are [correct](https://dl.acm.org/doi/10.1145/3497775.3503687).
